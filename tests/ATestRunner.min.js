/**
 * @author Holmes Bryant <https://github.com/HolmesBryant>
 * @version 3.0.0
 * @license MIT
 */
class e{currentLine=null;onlyFailed=!1;timeout=2e3;resultEventName="a-testresult";progressEventName="a-progress";completeEventName="a-complete";#e=Promise.resolve();#t="pass";#s;#r=[];#i;#n="console";#o=null;constructor(e){this.#s=e,this.#i=new s,this.group=this.group.bind(this),this.info=this.info.bind(this),this.skip=this.skip.bind(this),this.test=this.test.bind(this),this.when=this.when.bind(this),this.profile=this.profile.bind(this),this.run=this.run.bind(this)}async benchmark(e,t=1,s=null,...r){const i=performance.now();for(let i=0;i<t;i++)await e.apply(s,r);return performance.now()-i}equal(e,t){const s=new Map;return this.#a(e,t,s)}*genCombos(e={}){const t=Object.keys(e),s=Object.values(e);yield*function*e(r,i){if(r===t.length)return void(yield{...i});const n=t[r],o=s[r];if(Array.isArray(o))for(const t of o)i[n]=t,yield*e(r+1,i);else i[n]=o,yield*e(r+1,i)}(0,{})}group(e,t){this.#e=this.#e.then(async()=>{this.#r.push({type:"group_start",payload:{gist:e}}),await t(),this.#r.push({type:"group_end",payload:{}})})}handleError(e,t={}){let s;const r=t.code??null,i=t.line??this.currentLine??(this.#s?this.#u():null);s=t.gist?t.gist:r?`Failed to execute:\n${r}`:"Error during setup",this.#r.push({type:"test",payload:{gist:s,testFn:e,expect:null,line:i,verdict:"error"}})}info(e){this.#r.push({type:"info",payload:{message:e}})}async profile(e,t,s=this,...r){let i=this[e];return i||("executeTest"===e?i=this.#l:"getLine"===e&&(i=this.#u)),this.benchmark(i,t,s,...r)}skip(e,t,s){const r=this.currentLine??(this.#s?this.#u():null);this.#r.push({type:"skip",payload:{gist:e,testFn:t,expect:s,line:r,verdict:"skip"}})}spyOn(e,t){const s=e[t];if("function"!=typeof s)throw new Error(`'${t}' must be a function on the object.`);let r=s;const i={callCount:0,calls:[],restore:()=>{e[t]=s},runs(e){return r=e,this},returns(e){return r=()=>e,this},resolves(e){return r=()=>Promise.resolve(e),this},rejects(e){return r=()=>Promise.reject(e),this}};return e[t]=function(...e){return i.callCount++,i.calls.push(e),r.apply(this,e)},i}test(e,t,s,r={}){const i={gist:e,testFn:t,expect:s,line:this.currentLine??(this.#s?this.#u():null),...r};this.#r.push({type:"test",payload:i})}throws(e,...t){try{return e(...t),!1}catch(e){return!0}}async wait(e){return new Promise(t=>setTimeout(t,e))}async when(e,t=1e3,s=100){const r=Date.now(),i="function"==typeof e?async()=>e():async()=>e;for(;;){if(Date.now()-r>=t)return await i();try{const e=await i();if(e)return e}catch(e){throw e}await this.wait(s)}}async run(){await this.#e,await this.#c(),this.#i.progress(0,this.#r.length),await this.#p(),this.#i.complete(this.#t)}#h(e){this.#e=this.#e.then(e)}#g(e){return"info"===e.type?Promise.resolve({type:"info",message:e.payload.message}):this.#l(e.payload)}async#l(e){const{gist:t,testFn:s,expect:r,line:i,verdict:n,timeout:o}=e,a=o??this.timeout;try{if(n)return{type:"test",gist:t,verdict:n,result:"error"===n?s:"Not executed",expect:r,line:i};const e=new Promise((e,t)=>setTimeout(()=>t(new Error(`Test timed out after ${a}ms`)),a)),o=(async()=>{const e="function"==typeof s?s():s;if(e instanceof Error)return{type:"test",gist:t,verdict:"error",result:e,expect:r,line:i};const n=await e,o=this.equal(n,r)?"pass":"fail";return{type:"test",gist:t,verdict:o,result:n,expect:r,line:i}})();return await Promise.race([o,e])}catch(e){return{type:"test",gist:t,verdict:"error",result:e,expect:r,line:i}}}#u(){try{throw new Error}catch(e){if(!e.stack)return null;const t=e.stack.split("\n").find(e=>e.includes(this.#s));if(!t)return null;const s=t.indexOf(this.#s)+this.#s.length+1,r=t.lastIndexOf(":");return t.substring(s,r)}}async#p(){const e=[[]];let t=!1;for(const[s,r]of this.#r.entries()){switch(r.type){case"group_start":this.#i.groupStart(r.payload.gist),t=!0;break;case"group_end":const s=e[e.length-1];await this.#f(s),s.length=0,this.#i.groupEnd(),t=!1;break;default:const i=this.#g(r);if(t)e[e.length-1].push(i);else{const e=await i;this.#d(e)}}this.#i.progress(s+1,this.#r.length)}}async#f(e){const t=await Promise.all(e);for(const e of t)this.#d(e)}#d(e){"fail"!==e.verdict&&"error"!==e.verdict||(this.#t="fail"),this.onlyFailed&&"pass"===e.verdict||this.#i.report(e)}async#c(){if("console"===this.#n||null===this.#n)return this.#o="console",void(this.#i=new s);let e;if(this.#n instanceof HTMLElement?e=this.#n:"string"==typeof this.#n&&(e=document.querySelector(this.#n)),!e)throw new Error(`ATestRunner Error: Output target "${this.#n}" not found in the DOM.`);if(e.localName.includes("-"))try{await customElements.whenDefined(e.localName),await new Promise(e=>requestAnimationFrame(e))}catch(t){console.warn(`ATestRunner: Could not wait for custom element '${e.localName}' to be defined. It may not have been registered.`,t)}this.#o=e,this.#i=new r(e,{result:this.resultEventName,progress:this.progressEventName,complete:this.completeEventName})}#a(e,t,s){return e===t||null!==e&&"object"==typeof e&&null!==t&&"object"==typeof t&&(!(!s.has(e)||s.get(e)!==t)||(s.set(e,t),Object.getPrototypeOf(e)===Object.getPrototypeOf(t)&&(e instanceof Date?e.getTime()===t.getTime():e instanceof RegExp?e.toString()===t.toString():Array.isArray(e)?this.#m(e,t,s):e instanceof Map?this.#y(e,t,s):e instanceof Set?this.#w(e,t,s):e instanceof ArrayBuffer||ArrayBuffer.isView(e)?this.#E(e,t):this.#b(e,t,s))))}#m(e,t,s){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(!this.#a(e[r],t[r],s))return!1;return!0}#y(e,t,s){if(e.size!==t.size)return!1;for(const[r,i]of e)if(!t.has(r)||!this.#a(i,t.get(r),s))return!1;return!0}#w(e,t,s){if(e.size!==t.size)return!1;const r=[...t];for(const t of e){const e=r.findIndex(e=>this.#a(t,e,s));if(-1===e)return!1;r.splice(e,1)}return!0}#E(e,t){if(e.byteLength!==t.byteLength)return!1;const s=new Uint8Array(e.buffer,e.byteOffset,e.byteLength),r=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);for(let t=0;t<e.byteLength;t++)if(s[t]!==r[t])return!1;return!0}#b(e,t,s){const r=Object.keys(e);if(r.length!==Object.keys(t).length)return!1;for(const i of r)if(!Object.prototype.hasOwnProperty.call(t,i)||!this.#a(e[i],t[i],s))return!1;return!0}get output(){return this.#n}set output(e){this.#n=e}get finalVerdict(){return this.#t}}class t{report(e){throw new Error("ATestReporter.report() must be implemented by subclasses.")}groupStart(e){throw new Error("ATestReporter.groupStart() must be implemented by subclasses.")}groupEnd(){throw new Error("ATestReporter.groupEnd() must be implemented by subclasses.")}progress(e,t){throw new Error("ATestReporter.progress() must be implemented by subclasses.")}complete(e){throw new Error("ATestReporter.complete() must be implemented by subclasses.")}}class s extends t{#v(e){switch(e){case"pass":return"color:limegreen; font-weight:bold";case"fail":return"color:red; font-weight:bold";case"info":return"color:SandyBrown; font-weight:bold";case"GROUP_START":return"color:darkorange; font-weight:bold";case"error":return"color:fuchsia; font-weight:bold;";default:return"color:dodgerblue; font-weight:bold"}}report(e){const{gist:t,verdict:s,result:r,expect:i,line:n,message:o,type:a}=e;if("info"===a)return void console.log("%cINFO",this.#v("info"),o);const u=[`%c${s.toUpperCase()}`,this.#v(s),t];console.groupCollapsed(...u),console.log("Result:",r),console.log("Expected:",i),n&&console.log("Line:",n),console.groupEnd()}groupStart(e){console.group(`%c${e}`,this.#v("GROUP_START"))}groupEnd(){console.groupEnd()}progress(e,t){}complete(e){console.log("%cDONE",this.#v("done"))}}class r extends t{#O;#T;#R;#x;constructor(e,t){super(),this.#O=e,this.#T=t.result,this.#R=t.progress,this.#x=t.complete}#C(e,t){const s=new CustomEvent(e,{detail:t,bubbles:!0,composed:!0});this.#O.dispatchEvent(s)}#L(e){const{gist:t,verdict:s,result:r,expect:i,line:n,message:o,type:a}=e,u="info"===a?{gist:o,verdict:"INFO"}:{gist:t,verdict:s.toUpperCase(),result:r,expect:i,line:n};return u.result instanceof Error&&(u.result=u.result.stack?u.result.stack.split("\n"):u.result.message),u}report(e){this.#C(this.#T,this.#L(e))}groupStart(e){this.#C(this.#T,{gist:e,verdict:"GROUP_START"})}groupEnd(){this.#C(this.#T,{gist:null,verdict:"GROUP_END"})}progress(e,t){const s=new ProgressEvent(this.#R,{lengthComputable:!0,loaded:e,total:t});this.#O.dispatchEvent(s)}complete(e){this.#C(this.#x,{verdict:e})}}export{e as default};
